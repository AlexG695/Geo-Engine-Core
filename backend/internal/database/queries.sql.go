// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"

	"github.com/google/uuid"
)

const createGeofence = `-- name: CreateGeofence :one
INSERT INTO geofences (name, area)
VALUES ($1, ST_GeomFromGeoJSON($2)) -- <-- Recibe un string GeoJSON
    RETURNING id, name
`

type CreateGeofenceParams struct {
	Name              string      `json:"name"`
	StGeomfromgeojson interface{} `json:"st_geomfromgeojson"`
}

type CreateGeofenceRow struct {
	ID   uuid.UUID `json:"id"`
	Name string    `json:"name"`
}

func (q *Queries) CreateGeofence(ctx context.Context, arg CreateGeofenceParams) (CreateGeofenceRow, error) {
	row := q.db.QueryRowContext(ctx, createGeofence, arg.Name, arg.StGeomfromgeojson)
	var i CreateGeofenceRow
	err := row.Scan(&i.ID, &i.Name)
	return i, err
}

const createLocation = `-- name: CreateLocation :one
INSERT INTO locations (
    id, device_id, latitude, longitude, accuracy, heading, speed, is_mock, created_at
) VALUES (
             $1, $2, $3, $4, $5, $6, $7, $8, $9
         )
    RETURNING id
`

type CreateLocationParams struct {
	ID        uuid.UUID       `json:"id"`
	DeviceID  string          `json:"device_id"`
	Latitude  float64         `json:"latitude"`
	Longitude float64         `json:"longitude"`
	Accuracy  sql.NullFloat64 `json:"accuracy"`
	Heading   sql.NullFloat64 `json:"heading"`
	Speed     sql.NullFloat64 `json:"speed"`
	IsMock    sql.NullBool    `json:"is_mock"`
	CreatedAt sql.NullTime    `json:"created_at"`
}

// Guarda una nueva ubicación y devuelve el ID insertado.
func (q *Queries) CreateLocation(ctx context.Context, arg CreateLocationParams) (uuid.UUID, error) {
	row := q.db.QueryRowContext(ctx, createLocation,
		arg.ID,
		arg.DeviceID,
		arg.Latitude,
		arg.Longitude,
		arg.Accuracy,
		arg.Heading,
		arg.Speed,
		arg.IsMock,
		arg.CreatedAt,
	)
	var id uuid.UUID
	err := row.Scan(&id)
	return id, err
}

const deleteGeofence = `-- name: DeleteGeofence :exec
DELETE FROM geofences WHERE id = $1
`

func (q *Queries) DeleteGeofence(ctx context.Context, id uuid.UUID) error {
	_, err := q.db.ExecContext(ctx, deleteGeofence, id)
	return err
}

const findGeofencesContainingPoint = `-- name: FindGeofencesContainingPoint :many
SELECT id, name
FROM geofences
WHERE ST_Contains(area, ST_SetSRID(ST_MakePoint($1, $2), 4326))
`

type FindGeofencesContainingPointParams struct {
	StMakepoint   interface{} `json:"st_makepoint"`
	StMakepoint_2 interface{} `json:"st_makepoint_2"`
}

type FindGeofencesContainingPointRow struct {
	ID   uuid.UUID `json:"id"`
	Name string    `json:"name"`
}

func (q *Queries) FindGeofencesContainingPoint(ctx context.Context, arg FindGeofencesContainingPointParams) ([]FindGeofencesContainingPointRow, error) {
	rows, err := q.db.QueryContext(ctx, findGeofencesContainingPoint, arg.StMakepoint, arg.StMakepoint_2)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []FindGeofencesContainingPointRow
	for rows.Next() {
		var i FindGeofencesContainingPointRow
		if err := rows.Scan(&i.ID, &i.Name); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getDriverRoute = `-- name: GetDriverRoute :one
SELECT
    COALESCE(
            ST_AsGeoJSON(ST_MakeLine(geom ORDER BY created_at))::text,
            '{"type": "LineString", "coordinates": []}'
    )::text as geojson_route
FROM locations
WHERE
    device_id = $1
`

func (q *Queries) GetDriverRoute(ctx context.Context, deviceID string) (string, error) {
	row := q.db.QueryRowContext(ctx, getDriverRoute, deviceID)
	var geojson_route string
	err := row.Scan(&geojson_route)
	return geojson_route, err
}

const getGeofences = `-- name: GetGeofences :many
SELECT id, name, ST_AsGeoJSON(area)::text as geojson
FROM geofences
`

type GetGeofencesRow struct {
	ID      uuid.UUID `json:"id"`
	Name    string    `json:"name"`
	Geojson string    `json:"geojson"`
}

func (q *Queries) GetGeofences(ctx context.Context) ([]GetGeofencesRow, error) {
	rows, err := q.db.QueryContext(ctx, getGeofences)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetGeofencesRow
	for rows.Next() {
		var i GetGeofencesRow
		if err := rows.Scan(&i.ID, &i.Name, &i.Geojson); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getLatestLocationByDevice = `-- name: GetLatestLocationByDevice :one
SELECT id, device_id, latitude, longitude, geom, h3_ix, accuracy, heading, speed, is_mock, created_at FROM locations
WHERE device_id = $1
ORDER BY created_at DESC
    LIMIT 1
`

// Obtiene la última ubicación conocida de un dispositivo.
func (q *Queries) GetLatestLocationByDevice(ctx context.Context, deviceID string) (Location, error) {
	row := q.db.QueryRowContext(ctx, getLatestLocationByDevice, deviceID)
	var i Location
	err := row.Scan(
		&i.ID,
		&i.DeviceID,
		&i.Latitude,
		&i.Longitude,
		&i.Geom,
		&i.H3Ix,
		&i.Accuracy,
		&i.Heading,
		&i.Speed,
		&i.IsMock,
		&i.CreatedAt,
	)
	return i, err
}

const getNearbyDrivers = `-- name: GetNearbyDrivers :many
SELECT
    id, device_id, latitude, longitude, heading, speed, created_at
FROM locations
WHERE
  -- Compara la columna geom contra un punto creado al vuelo
    ST_DWithin(
            geom,
            ST_SetSRID(ST_MakePoint($1::float8, $2::float8), 4326)::geography,
            $3::float8
    )
  AND created_at > NOW() - INTERVAL '5 minutes' -- Solo conductores activos recientemente
ORDER BY created_at DESC
`

type GetNearbyDriversParams struct {
	Lng          float64 `json:"lng"`
	Lat          float64 `json:"lat"`
	RadiusMeters float64 `json:"radius_meters"`
}

type GetNearbyDriversRow struct {
	ID        uuid.UUID       `json:"id"`
	DeviceID  string          `json:"device_id"`
	Latitude  float64         `json:"latitude"`
	Longitude float64         `json:"longitude"`
	Heading   sql.NullFloat64 `json:"heading"`
	Speed     sql.NullFloat64 `json:"speed"`
	CreatedAt sql.NullTime    `json:"created_at"`
}

// Busca conductores dentro de un radio (en metros) usando PostGIS.
// ST_DWithin usa índices espaciales, así que es ULTRA rápido.
func (q *Queries) GetNearbyDrivers(ctx context.Context, arg GetNearbyDriversParams) ([]GetNearbyDriversRow, error) {
	rows, err := q.db.QueryContext(ctx, getNearbyDrivers, arg.Lng, arg.Lat, arg.RadiusMeters)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetNearbyDriversRow
	for rows.Next() {
		var i GetNearbyDriversRow
		if err := rows.Scan(
			&i.ID,
			&i.DeviceID,
			&i.Latitude,
			&i.Longitude,
			&i.Heading,
			&i.Speed,
			&i.CreatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const logGeofenceEvent = `-- name: LogGeofenceEvent :exec
INSERT INTO geofence_events (geofence_id, device_id, event_type)
VALUES ($1, $2, $3)
`

type LogGeofenceEventParams struct {
	GeofenceID uuid.UUID `json:"geofence_id"`
	DeviceID   string    `json:"device_id"`
	EventType  string    `json:"event_type"`
}

func (q *Queries) LogGeofenceEvent(ctx context.Context, arg LogGeofenceEventParams) error {
	_, err := q.db.ExecContext(ctx, logGeofenceEvent, arg.GeofenceID, arg.DeviceID, arg.EventType)
	return err
}

const updateGeofence = `-- name: UpdateGeofence :one
UPDATE geofences
SET
    name = $2,
    area = CASE
               WHEN length($3::text) > 0 THEN ST_GeomFromGeoJSON($3)
               ELSE area
        END
WHERE id = $1
    RETURNING id, name, ST_AsGeoJSON(area)::text as geojson
`

type UpdateGeofenceParams struct {
	ID      uuid.UUID `json:"id"`
	Name    string    `json:"name"`
	Column3 string    `json:"column_3"`
}

type UpdateGeofenceRow struct {
	ID      uuid.UUID `json:"id"`
	Name    string    `json:"name"`
	Geojson string    `json:"geojson"`
}

func (q *Queries) UpdateGeofence(ctx context.Context, arg UpdateGeofenceParams) (UpdateGeofenceRow, error) {
	row := q.db.QueryRowContext(ctx, updateGeofence, arg.ID, arg.Name, arg.Column3)
	var i UpdateGeofenceRow
	err := row.Scan(&i.ID, &i.Name, &i.Geojson)
	return i, err
}
